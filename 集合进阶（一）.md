# 集合进阶（一）

**Collection**代表单列集合，每个元素（数据）只包含一个值。

**Map**代表双列集合，每个元素包含两个值（键值对）。



# 一、Collection\<E>集合体系

**为啥要先Collection的常用方法？** 

Collection是单列集合的祖宗，它规定的方法（功能）是全部单列集合都会继承的。

| 常见方法     **方法名**                 | **说明**                         |
| --------------------------------------- | -------------------------------- |
| public boolean **add**(E e)             | 把给定的对象添加到当前集合中     |
| public void **clear**()                 | 清空集合中所有的元素             |
| public boolean **remove(E e)**          | 把给定的对象在当前集合中删除     |
| public boolean **contains(Object obj)** | 判断当前集合中是否包含给定的对象 |
| public boolean **isEmpty()**            | 判断当前集合是否为空             |
| public int **size()**                   | 返回集合中元素的个数。           |
| public Object[] **toArray()**           | 把集合中的元素，存储到数组中     |

```Java
String[] arr2 = c.toArray(new String[c.size()]);
System.out.println(Arrays.toString(arr2));
```





## 1、List\<E>

* **List系列集合：**添加的元素是有序、可重复、有索引。

  ​	ArrayList 、LinekdList : 有序、可重复、有索引。

  特有方法：

  | **方法名称**                       | **说明**                               |
  | ---------------------------------- | -------------------------------------- |
  | void **add(int  index,E element)** | 在此集合中的指定位置插入指定的元素     |
  | E **remove(int  index)**           | 删除指定索引处的元素，返回被删除的元素 |
  | E **set(int index,E  element)**    | 修改指定索引处的元素，返回被修改的元素 |
  | E **get(int  index)**              | 返回指定索引处的元素                   |

## 2、ArrayList集合

**一.ArrayList集合的底层原理**		**基于数组  查询快、增删慢**

​	1.利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组

​	2.添加第一个元素时底层会创建一个新的长度为10的数组

​	3.存满时，会自动扩容1.5倍

​	4.如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准。

**二.ArrayList集合使用于什么业务场景？不适合什么**

​	1、**ArrayList集合适合：**根据索引查询数据，比如根据随机索引取数据（高效）！或者数据量不是很大时使用！

​	2、**ArrayList集合不适合：**数据量大时，又要频繁的进行增删操作！



## 3、LinkedList 集合		基于双链表

LinkedList新增很多首尾操作的特有方法

* 应用场景一：可以用来设计**队列**    特点：先进先出，后进后出

* 应用场景二：可以用来设计**栈**   特点：后进先出，先进后出

  ​	数据进入栈模型的过程：压/进栈（push）

  ​	数据离开栈模型的过程：弹/出栈（pop）



| **方法名称**                   | **说明**                         |
| ------------------------------ | -------------------------------- |
| public  void **addFirst(E e)** | 在该列表开头插入指定的元素       |
| public  void **addLast(E e)**  | 将指定的元素追加到此列表的末尾   |
| public  **E getFirst()**       | 返回此列表中的第一个元素         |
| public  **E getLast()**        | 返回此列表中的最后一个元素       |
| public  **E removeFirst()**    | 从此列表中删除并返回第一个元素   |
| public  **E removeLast()**     | 从此列表中删除并返回最后一个元素 |

## 4、链表

| 头节点\|下个数据地址 | 11 \|       | 54 \|      | 44 \|  |
| -------------------- | ----------- | ---------- | ------ |
| A  \|  11    —>      | B \| 54  —> | C \| 44 —> | D \| ^ |

、、链表中的结点是独立的对象，在内存中是不连续的，**每个结点包含数据值和下一个结点的地址。**

​		链表的特点1：查询慢，无论查询哪个数据都要从头开始找。

​		链表的特点2：链表增删相对快。

## 5、双链表

| 头结点                  | 每个节点双向连接             | 尾结点           |
| ----------------------- | ---------------------------- | ---------------- |
| ^ \| 值 \| 下个节点地址 | 前一个结点地址 \|值 \|下地址 | 前地址 \|值 \| ^ |

**特点：**查询慢，增删相对较快，**但对首尾元素进行增删改查的速度是极快的**







## 6、Set\<E>

* **Set系列集合：**添加的元素是无序、不重复、无索引。

  ​	HashSet : 无序、不重复、无索引。

  ​		LinkedHashSet ： **有序**、不重复、无索引。

  ​	TreeSet ：**按照大小默认升序排序**、不重复、无索引。

**注意：Set 要用到的常用方法，基本是Collection 提供的。自己几乎没有额外的常用功能。。**

​		

## 7、HashSet集合底层原理

### 7.1、基于哈希表实现

**注意：在正式了解HashSet集合的底层原理前，我们需要先搞清楚一个前置知识：哈希值！**

### 7.2、哈希值

* 就是一个int类型的数值，Java中每一个对象都有一个哈希值。

* Java中的所有对象，都可以通过调用Obejct类提供的hashCode方法，返回自己的哈希值

  ```Java
  public int hashCode() :返回对象的哈希值	
  ```

**对象哈希值的特点**

​	同一对象多次调用hashCode()方法返回的哈希值是相同的；

​	不同的对象，它们的哈希值一般不相同，但也有可能会相同（**哈希碰撞**）  

​			int （-21亿多 ~ 21亿多）		45亿个对象

哈希表是一种增删改查数据，性能都较好的数据结构。

**哈希表**

* JDK8 之前，**哈希表 = 数组 +链表**
* JDK8 以后，**哈希表 = 数组+链表+红黑树**

### 7.3、JDK8之前HashSet集合的底层原理，基于哈希表：数组+链表

```
1、创建一个默认长度16的数组，默认加载因子为0.75，数组名table
2、使用元素的哈希值对数组的长度求余计算出应存入的位置
3、判断当前位置是否为null，如果是null直接存入
4、如果不为null，表示有元素，则调用equals方法比较
         相等，则不存；不相等，则存入数组
* JDK 8之前，新元素存入数组，占老元素位置，老元素挂下面
* JDK 8开始之后，新元素直接挂在老元素下面
```

**JDK8开始，当链表长度超过8，且数组长度>=64时，自动将链表转成红黑树**

**结论：如果希望Set集合认为2个内容一样的对象是重复的，**

**必须重写对象的hashCode()和equals()方法**



## 8、LinkedHashSet 集合

依然是基于哈希表(数组、链表、红黑树)实现的。

但是，它的每个元素都额外的多了一个双链表的机制记录它前后元素的位置。

## 9、TreeSet

​	特点：不重复、无索引、可排序（默认升序排序 ，按照元素的大小，由小到大排序）

​	底层是基于红黑树实现的排序。

**注意**

​	对于数值类型：Integer , Double，默认按照数值本身的大小进行升序排序。

​	对于字符串类型：默认按照首字符的编号升序排序。

​	**对于自定义类型如Student对象，TreeSet默认是无法直接排序的。**

## 【】自定义排序规则

​	TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式来指定比较规则。

**方式一**

​	 让自定义的类（如学生类）**实现Comparable接口，重写里面的compareTo方法来指定比较规则。**

```java 
// this  o
@Override
public int compareTo(Student o) {
    // 如果认为左边对象大于右边对象返回正整数
    // 如果认为左边对象小于右边对象返回负整数
    // 如果认为左边对象等于右边对象返回0
    // 需求：按照年龄升序排序、
    return this.age - o.age;
}
```

**方式二**

​	**通过调用TreeSet集合有参数构造器，可以设置Comparator对象（比较器对象，用于指定比较规则。**

```java
public TreeSet(Co,patator<? super E > comparator)
```

```java 
       // default void forEach(Consumer<? super T> action):  结合Lambda表达式遍历集合：
//        c.forEach(new Consumer<String>() {
//            @Override
//            public void accept(String s) {
//                System.out.println(s);
//            }
//        });

//        c.forEach((String s) -> {
//                System.out.println(s);
//        });
//
//        c.forEach(s  -> {
//            System.out.println(s);
//        });

//        c.forEach(s  -> System.out.println(s) );

        c.forEach(System.out::println );
    }
```

1、如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据？

​		常用ArrayList集合（有序 、可重复、有索引），底层是基于数组的。（常用）

2、如果希望机组元素的添加顺序，且增删数据的情况较多？

​		用LinkedList集合（有序、可重复、有索引），底层是基于双链表实现的。

3、如果不在意元素顺序，也没有重复元素需要储存，只希望增删改查都快？

​		用HashSet集合（无序、不重复、无索引），底层基于哈希表实现，（常用0

4、如果希望记住元素的添加顺序，也没有重复元素需要储存，且希望增删改查都快？

​		用LinkedHashSet集合（有序、不重复、无索引），底层基于哈希表和双链表。

5、如果要对元素进行排序，也没有重复元素需要储存?且希望增删改查都快？

​		用TreeSet集合，基于红黑树实现。

## 【】集合的并发修改异常

* 使用迭代器遍历集合是，又同时在删除集合中的数据，程序就会出现并发修改异常
* 由于增强for循环遍历集合就是迭代器遍历集合的简化写法，因此，使用增强for循环遍历集合，又在同时删除集合中的数据时，程序也会出现并发修改异常的错误。

## 【】怎样保证遍历集合同时删除数据时不出现bug？

* 使用迭代器遍历集合，但用迭代器自己的山粗方法删除数据即可。
* 如果能用for循环遍历时：可倒着遍历并删除；或者从前往后遍历，但删除元素后进行i--操作





## 10、迭代器

​	迭代器是用来遍历集合的专用方式(数组没有迭代器)，在Java中迭代器的代表是**Iterator**。

**Collection集合获取迭代器的方法**

| **方法名称**                | **说明**                                                     |
| --------------------------- | ------------------------------------------------------------ |
| Iterator<E>  **iterator()** | 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素 |

**Iterator跌代器中的常用方法**

| **方法名称**          | **说明**                                                   |
| --------------------- | ---------------------------------------------------------- |
| boolean **hasNext()** | 询问当前位置是否有元素存在，存在返回true  ,不存在返回false |
| **E.next()**          | 获取当前位置的元素，并同时将迭代器对象指向下一个元素处。   |

```Java
// 2、我们应该使用循环结合迭代器遍历集合。
Iterator<String> it = c.iterator();
while (it.hasNext()){
    String ele = it.next();// E.next()  
    System.out.println(ele);

}
```

通过迭代器获取集合的元素，如果取元素越界会出现什么异常?

**会出现NoSuchElementException异常。**



## 11、增强for循环

```Java
String[] names = {"迪丽热巴", "古力娜扎", "稀奇哈哈"};
for (String name : names) {
    System.out.println(name);
}
```



## 12、Lambda表达式遍历集合



### 需要使用Collection的如下方法来完成

| **方法名称**                                         | **说明**           |
| ---------------------------------------------------- | ------------------ |
| default void **forEach(Consumer<? super T> action)** | 结合lambda遍历集合 |

```java 
Collection<String> lists = new ArrayList<>();
...
lists.forEach(new Collection<String>(){
	public void accept(String s){
		System.out.print(s);
	}
});

//Lanbda表达式简化后
lists.forEach(s ->{System.out.println(s);})
```

